'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _Factory = require('./Factory');

var _Factory2 = _interopRequireDefault(_Factory);

var singleton = Symbol();
var singletonEnforcer = Symbol();

/**
 * Client is the responsible of comunicate with the API.
 */

var Client = (function () {

  /**
   * Constructor
   *
   * @param {Symbol} enforcer
   */

  function Client(enforcer) {
    _classCallCheck(this, Client);

    this._token = null;
    this._clientId = null;
    this._secretId = null;
    this._scopes = null;
    this._redirect_uri = null;

    if (enforcer != singletonEnforcer) {
      throw "Cannot construct singleton";
    }
  }

  /**
   * Exports the Client class.
   */

  /**
   * Get the current instance of Client
   *
   * @return {Object} instance
   */

  _createClass(Client, [{
    key: 'login',

    /**
     * This method fires a new window that allow login
     *
     * @param  {Function} callback
     * @return {Function|Promise}
     */
    value: function login(callback) {
      var url_login = 'https://accounts.spotify.com/en/authorize?response_type=token&client_id=' + this._clientId + '&redirect_uri=' + encodeURIComponent(this._redirect_uri) + (this._scopes ? '&scope=' + encodeURIComponent(this._scopes) : '');
      if (callback) {
        return callback(url_login);
      } else {
        return new Promise(function (resolve) {
          resolve(url_login);
        });
      }
    }

    /**
     * @param  {String} url Endpoint
     * @param  {String} method Method GET, POST, PUT or DELETE
     * @param  {Object} body Objet to send in the body
     * @return {Promise}
     */
  }, {
    key: 'request',
    value: function request(url, method, body) {
      return this.fetch(url, method, body).then((function (data) {
        return (0, _Factory2['default'])(data);
      }).bind(this));
    }

    /**
     * Function that encode objects
     *
     * @param  {Object} obj Object to encode
     * @return {String} A encode object
     */
  }, {
    key: 'toQueryString',
    value: function toQueryString(obj) {
      var str = [];
      for (var p in obj) {
        if (obj.hasOwnProperty(p)) {
          str.push(encodeURIComponent(p) + "=" + encodeURIComponent(obj[p]));
        }
      }return str.join("&");
    }

    /**
     * @param  {String} endpoint Endpoint
     * @param  {String} method Method GET, POST, PUT or DELETE
     * @param  {Object} body Objet to send in the body
     * @return {Promise}
     */
  }, {
    key: 'fetch',
    value: (function (_fetch) {
      function fetch(_x, _x2, _x3) {
        return _fetch.apply(this, arguments);
      }

      fetch.toString = function () {
        return _fetch.toString();
      };

      return fetch;
    })(function (endpoint, method, body) {
      var _headers = { 'Accept': 'application/json' };
      var _url = undefined;
      var _body = undefined;

      if (this._token) {
        _headers.Authorization = 'Bearer ' + this._token;
      }

      if (endpoint.indexOf('https') > -1) {
        _url = endpoint;
      } else {
        _url = 'https://api.spotify.com/v1' + endpoint;
      }

      if (method === 'GET') {
        if (body) {
          var separator = _url.indexOf('?') !== -1 ? "&" : "?";
          _url = _url + separator + this.toQueryString(body);
        }
      } else {
        _body = JSON.stringify(body);
      }

      var checkStatus = function checkStatus(response) {
        if (response.status >= 200 && response.status < 300) {
          return response;
        } else {
          var error = new Error(response.statusText);
          error.response = response;
          throw error;
        }
      };

      var parseJSON = function parseJSON(response) {
        if (response.statusText === 'No Content') {
          return { type: 'undefineds' };
        }
        return response.json();
      };

      return fetch(_url, {
        method: method || 'GET',
        headers: _headers,
        body: _body
      }).then(checkStatus).then(parseJSON);
    })
  }, {
    key: 'settings',

    /**
     * Set settings
     *
     * @param {Object} settings Settings
     */
    set: function set(settings) {
      this._token = settings.token;
      this._clientId = settings.clientId;
      this._secretId = settings.secretId;
      this._scopes = settings.scopes;
      this._redirect_uri = settings.redirect_uri;
    }

    /**
     * Set token
     *
     * @param {String} data Token
     */
  }, {
    key: 'token',
    set: function set(data) {
      this._token = data;
    },

    /**
     * Get the current token
     *
     * @return {String} Current token
     */
    get: function get() {
      return this._token;
    }
  }], [{
    key: 'instance',
    get: function get() {
      if (!this[singleton]) {
        this[singleton] = new Client(singletonEnforcer);
      }
      return this[singleton];
    }
  }]);

  return Client;
})();

exports['default'] = Client;
module.exports = exports['default'];